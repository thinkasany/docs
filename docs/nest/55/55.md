[基于 ACL 实现权限控制](https://juejin.cn/book/7226988578700525605/section/7246991031311761463)

[源码地址](https://github.com/thinkasany/nestjs-course-code/tree/master/55/acl-test)

上节我们实现了注册和登录，有的接口只有登录可以访问，会在 Guard 里做身份验证（Authentication）。

<img src="/docs/nest/55/image/1.webp" style="width: 600px; height: 300px;"/>

但有的接口，不只需要登录，可能还需要一定的权限，这时就需要鉴权（Authorization）。

比如管理员登录后，可以调用用户管理的接口，但普通用户登录后就不可以。

<img src="/docs/nest/55/image/2.webp"  style="width: 600px; height: 300px;"/>

也就是说，身份验证通过之后还需要再做一步权限的校验，也就是鉴权。

这俩单词也比较相似：身份验证（Authentication）、鉴权（Authorization）。

那怎么给不同用户分配权限呢？

最简单的方式自然是直接给用户分配权限：

<img src="/docs/nest/55/image/3.webp"  style="width: 600px; height: 600px;"/>

比如用户 1 有权限 A、B、C，用户 2 有权限 A，用户 3 有权限 A、B。

这种记录每个用户有什么权限的方式，叫做访问控制表（Access Control List）

用户和权限是多对多关系，存储这种关系需要用户表、角色表、用户-角色的中间表。

这节我们就来实现下 ACL 的权限控制。

在数据库中创建 acl_test 的 database。

```
CREATE DATABASE acl_test DEFAULT CHARACTER SET utf8mb4;
```

## 添加 User 和 Permission 的 Entity：

```
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class User {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    username: string;

    @Column({
        length: 50
    })
    password: string;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;
}
```

User 有 id、username、password、createTime、updateTime 5 个字段。

```
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class Permission {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    name: string;

    @Column({
        length: 100,
        nullable: true
    })
    desc: string;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;
}
```

permission 有 id、name、desc、createTime、updateTime 5 个字段，desc 字段可以为空。

然后在 User 里加入和 Permission 的关系，也就是多对多：

```
  @ManyToMany(() => Permission)
  @JoinTable({
    name: 'user_permission_relation',
  })
  permissions: Permission[];
```

通过 @ManyToMany 声明和 Permisssion 的多对多关系。

多对多是需要中间表的，通过 @JoinTable 声明，指定中间表的名字。

然后在 TypeOrm.forRoot 的 entities 数组加入这俩 entity：

运行服务

```
npm run start:dev
```

可以看到生成了 user、permission、user_permission_relation 这 3 个表。

并且中间表 user_permission_relation 还有 userId、permissionId 两个外键。

可以看到，3个表生成的都是对的，并且中间表的两个外键也都是主表删除或者更新时，从表级联删除或者更新。

## 插入数据

然后我们插入一些数据，不用 sql 插入，而是用 TypeORM 的 api 来插入：

修改下 UserService，添加这部分代码：

```
@InjectEntityManager()
entityManager: EntityManager;

async initData() {
    const permission1 = new Permission();
    permission1.name = 'create_aaa';
    permission1.desc = '新增 aaa';

    const permission2 = new Permission();
    permission2.name = 'update_aaa';
    permission2.desc = '修改 aaa';

    const permission3 = new Permission();
    permission3.name = 'remove_aaa';
    permission3.desc = '删除 aaa';

    const permission4 = new Permission();
    permission4.name = 'query_aaa';
    permission4.desc = '查询 aaa';

    const permission5 = new Permission();
    permission5.name = 'create_bbb';
    permission5.desc = '新增 bbb';

    const permission6 = new Permission();
    permission6.name = 'update_bbb';
    permission6.desc = '修改 bbb';

    const permission7 = new Permission();
    permission7.name = 'remove_bbb';
    permission7.desc = '删除 bbb';

    const permission8 = new Permission();
    permission8.name = 'query_bbb';
    permission8.desc = '查询 bbb';

    const user1 = new User();
    user1.username = '东东';
    user1.password = 'aaaaaa';
    user1.permissions  = [
      permission1, permission2, permission3, permission4
    ]

    const user2 = new User();
    user2.username = '光光';
    user2.password = 'bbbbbb';
    user2.permissions  = [
      permission5, permission6, permission7, permission8
    ]

    await this.entityManager.save([
      permission1,
      permission2,
      permission3,
      permission4,
      permission5,
      permission6,
      permission7,
      permission8
    ])
    await this.entityManager.save([
      user1,
      user2
    ]);
}
```

注入 EntityManager，实现权限和用户的保存。

aaa 增删改查、bbb增删改查，一个 8 个权限。

user1 有 aaa 的 4 个权限，user2 有 bbbb 的 4 个权限。

调用 entityManager.save 来保存。

然后改下 UserController：

```
@Get('init')
async initData() {
    await this.userService.initData();
    return 'done'
}
```

添加 init 的路由。

浏览器访问下：

```
localhost:3001/user/init
```

分别向 user、permission、user_permission_relation 中插入了数据。

- permission 表插入了 8 条权限记录
- user 表插入了 2 条用户记录
- user 表插入了 2 条用户记录
- 中间表插入了 8 条记录，两个用户各拥有 4 个权限

## 实现登录的接口

然后我们再实现登录的接口，这次通过 session + cookie 的方式。

安装 session 相关的包：

```
npm install express-session @types/express-session
```

在 main.ts 里使用这个中间件：

```
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as session from 'express-session';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.use(session({
    secret: 'guang',
    resave: false,
    saveUninitialized: false
  }));
  await app.listen(3000);
}
bootstrap();
```

secret 是加密 cookie 的密钥。

resave 是 session 没变的时候要不要重新生成 cookie。

saveUninitialized 是没登录要不要也创建一个 session。

然后在 UserController 添加一个 /user/login 的路由：

```
@Post('login')
login(@Body() loginUser: LoginUserDto, @Session() session){
    console.log(loginUser)
    return 'success'
}
```

全局启用 ValidationPipe(在main.ts中使用)

```
app.useGlobalPipes(new ValidationPipe());
```

接下来实现查询数据库的逻辑，在 UserService 添加 login 方法：

```
async login(loginUserDto: LoginUserDto) {
    const user = await this.entityManager.findOneBy(User, {
      username: loginUserDto.username
    });

    if(!user) {
      throw new HttpException('用户不存在', HttpStatus.ACCEPTED);
    }

    if(user.password !== loginUserDto.password) {
      throw new HttpException('密码错误', HttpStatus.ACCEPTED);
    }

    return user;
}
```

然后改下 UserController 的 login 方法：

```
@Post('login')
async login(@Body() loginUser: LoginUserDto, @Session() session){
    const user = await this.userService.login(loginUser);

    session.user = {
      username: user.username
    }

    return 'success';
}
```

调用 userService，并且把 user 信息放入 session。

再用 postman 登录下：

- 用户不存在：

```
{
    "username": "东东1",
    "password": "bb"
}
```

- 密码错误：

```
{
    "username": "东东",
    "password": "bb"
}
```

- 成功：

```
{
    "username": "东东",
    "password": "aaaaaa"
}
```

登录成功之后会返回 cookie，之后只要带上这个 cookie 就可以查询到服务端的对应的 session，从而取出 user 信息。

然后添加 aaa、bbb 两个模块，分别生成 CRUD 方法：

```
nest g resource aaa
nest g resource bbb
```
