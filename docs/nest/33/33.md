[一对一、join 查询、级联方式](https://juejin.cn/book/7226988578700525605/section/7237343058109399097)

数据库中会有很多的表，分别存储不同的信息，比如学生表存学生的信息、老师表存老师的信息，班级表存班级的信息。

这些表之间不是孤立的，有着一定的关系。

比如班级和学生之间是一对多的关系，也就是一个班级可以有多个学生。

班级和老师之间是多对多的关系，也就是一个班级可以有多个老师，一个老师也可以教多个班级。

如果存储一对一、一对多、多对多这些关系呢？

这就涉及到外键了。

比如一对一的关系，一个用户只能有一个身份证。

这样两个表，分别存储用户信息，还有身份证信息：

user

<!--  -->

| id   |
| ---- |
| name |

id_card

<!--  -->

| id        |
| --------- |
| card_name |

它们之间是一对一的关系，这时就可以用外键来表示

id_card

<!--  -->

| id        |
| --------- |
| card_name |
| user_id   |

user 表的主键是 id、可以通过 id 来唯一标识一个 user。

那 id_card 想查找 user，自然也是通过 id 来查找，多一个列来存储 user id 就可以实现这种一对一的关联。

这个 user_id 的列就是外键。

user 表叫主表，使用外键引用它的 id_card 表是从表。

```
CREATE TABLE `practice`.`user` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`id`)
);
```

```
CREATE TABLE `practice`.`id_card`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `card_name` varchar(255) NOT NULL,
  `user_id` int DEFAULT NULL,
  PRIMARY KEY (`id`),
  INDEX `card_id_idx`(`user_id`),
  CONSTRAINT `user_id` FOREIGN KEY (`user_id`) REFERENCES `practice`.`user` (`id`)
) CHARACTER SET = utf8mb4;
```

前面的三行都比较好理解，就是指定每一列的类型、约束、注释。

PRIMARY KEY 是指定 id 为主键。

INDEX 是建立索引，索引名是 card_id_idex，这个是用于加速 user_id 的访问的。

CONSTRINT user_id FOREIGN KEY 是给 user_id 添加一个外键约束，然后 user_id REFERENCES user id 则是指定 user_id 引用这 user 表的 id 列。

navicat 设置外键
<img src="/docs/nest/33/image/1.jpg" />
navicat 设置索引
<img src="/docs/nest/33/image/2.png" />

### 插入数据

```
INSERT INTO `user` (`name`)
	VALUES
		('张三'),
		('李四'),
		('王五'),
		('赵六'),
		('孙七'),
		('周八'),
		('吴九'),
		('郑十'),
		('钱十一'),
		('陈十二');
```

```
INSERT INTO id_card (card_name, user_id)
    VALUES
        ('110101199001011234',1),
	('310101199002022345',2),
	('440101199003033456',3),
	('440301199004044567',4),
	('510101199005055678',5),
	('330101199006066789',6),
	('320101199007077890',7),
	('500101199008088901',8),
	('420101199009099012',9),
	('610101199010101023',10);
```

## 关联查询

```
SELECT * FROM user JOIN id_card ON user.id = id_card.user_id;
```

这里用到了 JOIN ON，也就是连接 user 和 id_card 表，关联方式是 user.id = id_card.user_id，也就是 id_card 表中的外键关联 user 表的主键。

```
+----+-----------+----+--------------------+---------+
| id | name      | id | card_name          | user_id |
+----+-----------+----+--------------------+---------+
|  1 | 张三      | 31 | 110101199001011234 |       1 |
|  2 | 李四      | 32 | 310101199002022345 |       2 |
|  3 | 王五      | 33 | 440101199003033456 |       3 |
|  4 | 赵六      | 34 | 440301199004044567 |       4 |
|  5 | 孙七      | 35 | 510101199005055678 |       5 |
|  6 | 周八      | 36 | 330101199006066789 |       6 |
|  7 | 吴九      | 37 | 320101199007077890 |       7 |
|  8 | 郑十      | 38 | 500101199008088901 |       8 |
|  9 | 钱十一    | 39 | 420101199009099012 |       9 |
| 10 | 陈十二    | 40 | 610101199010101023 |      10 |
+----+-----------+----+--------------------+---------+
```

这里的两个 id 分别是 user 和 card 的 id，而且后面的 user_id 也没必要展示。

我们改下 sql：

```
SELECT user.id, name, id_card.id as card_id, card_name
    FROM user
    JOIN id_card ON user.id = id_card.user_id;
```

```
+----+-----------+---------+--------------------+
| id | name      | card_id | card_name          |
+----+-----------+---------+--------------------+
|  1 | 张三      |      31 | 110101199001011234 |
|  2 | 李四      |      32 | 310101199002022345 |
|  3 | 王五      |      33 | 440101199003033456 |
|  4 | 赵六      |      34 | 440301199004044567 |
|  5 | 孙七      |      35 | 510101199005055678 |
|  6 | 周八      |      36 | 330101199006066789 |
|  7 | 吴九      |      37 | 320101199007077890 |
|  8 | 郑十      |      38 | 500101199008088901 |
|  9 | 钱十一    |      39 | 420101199009099012 |
| 10 | 陈十二    |      40 | 610101199010101023 |
+----+-----------+---------+--------------------+
```

JOIN ON 其实默认是 INNER JOIN ON

INNER JOIN 是只返回两个表中能关联上的数据。

你还可以指定其余 2 种 join 类型：

LEFT JOIN 是额外返回左表中没有关联上的数据。

RIGHT JOIN 是额外返回右表中没有关联上的数据。

在 FROM 后的是左表，JOIN 后的表是右表。

## 删除和更新时的级联操作

- CASCADE： 主表主键更新，从表关联记录的外键跟着更新，主表记录删除，从表关联记录删除

- SET NULL：主表主键更新或者主表记录删除，从表关联记录的外键设置为 null

- RESTRICT：只有没有从表的关联记录时，才允许删除主表记录或者更新主表记录的主键 id

- NO ACTION： 同 RESTRICT，只是 sql 标准里分了 4 种，但 mysql 里 NO ACTION 等同于 RESTRICT。

<img src="/docs/nest/33/image/3.png" />

## RESTIRCT 和 NO ACTION 的处理逻辑：只要从表有关联记录，就不能更新 id 或者删除记录。

我们手动把从表记录的关联去掉，也就是删除第一条记录的外键
然后再试下主表的更新，这次就更新成功了！

## CASCADE

修改外键级联方式为 CASCADE。

在user表中，把 id 为 2 的 user 的 id 改为 22；

再看下 id_card 表的数据，你会发现 user_id 跟着改了。

然后把 id 为 22 的 user 删除掉；

再看下 id_card 表会发现那条 user_id 为 22 的记录也没了。

这就是级联方式为 CASCADE 的处理逻辑：主表删除，从表关联记录也级联删除，主表 id 更新，从表关联记录也跟着更新。

## set null

把 user 表中 id 为 5 的记录 id 改为 55
这时候 id_card 中那条记录的外键被置为 null 了

这就是 set null 的处理逻辑：主表记录删除或者修改 id，从表关联记录外键置为 null。

## 总结

这节我们学习了一对一的数据表设计，在从表里通过外键来关联主表的主键。

查询的时候需要使用 join on，默认是 inner join 也就是只返回有关联的记录，也可以用 left join、right join 来额外返回没有关联记录的左表或右表的记录。

from 后的是左表，join 后的是右表。

此外，外键还可以设置级联方式，也就是主表修改 id 或者删除的时候，从表怎么做。

有 3 种级联方式：CASCADE（关联删除或更新），SET NULL（关联外键设置为 null），RESTRICT 或者 NO ACTION（没有从表的关联记录才可以删除或更新）

多表的连接是非常常用的操作，下节我们继续学习一对多和多对多的数据表设计。

## others

使用navicat实践了一遍...
