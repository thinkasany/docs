[源码](https://github.com/thinkasany/nestjs-course-code/tree/master/19/pipe-test)

[掘金](https://juejin.cn/book/7226988578700525605/section/7235155965769678905)

> 暂时跳过了源码部分的解析，有需要请查看原著，我还是先看看使用，等待后续来完善

> 还剩下 ValidationPipe 和 ParseFilePipe，这个后续也补充一下吧。

Pipe 是在参数传给 handler 之前对参数做一些验证和转换的 class，对每个参数都会应用 pipe

内置的 Pipe 有这些：

- ValidationPipe
- ParseIntPipe
- ParseBoolPipe
- ParseArrayPipe
- ParseUUIDPipe
- DefaultValuePipe
- ParseEnumPipe
- ParseFloatPipe
- ParseFilePipe

# 创建项目：

```
nest new pipe-test -p npm
```

# 参数默认是 string 类型：

```
  @Get()
  getHello(@Query('aa') aa: string): string {
    return aa;
  }
```

# 我们可以通过 Pipe 把它转为整数：

```
  @Get()
  getHello(@Query('aa', ParseIntPipe) aa: number): number {
    return aa + 1;
  }
```

http://localhost:3000/?aa=11

```
12
```

http://localhost:3000/?aa=xx
当你传入的参数不能 parse 为 int 时，会返回这样的响应：

```
{"statusCode":400,"message":"Validation failed (numeric string is expected)","error":"Bad Request"}
```

# 自定义errorCode

这个也是可以修改的，但要使用 new XxxPipe 的方式：

```
  @Get('aa')
  aa(
    @Query(
      'aa',
      new ParseIntPipe({
        errorHttpStatusCode: HttpStatus.NOT_FOUND,
      }),
    )
    aa: number,
  ): number {
    return aa + 1;
  }
```

http://localhost:3000/aa?aa=xxx

```
{"statusCode":404,"message":"Validation failed (numeric string is expected)","error":"Not Found"}
```

# 自定义抛出异常

此外，你还可以自己抛一个异常出来，然后让 exception filter 处理：

```
@Get('bb')
  bb(
    @Query(
      'aa',
      new ParseIntPipe({
        exceptionFactory: (msg) => {
          console.log(msg);
          throw new HttpException('xxx ' + msg, HttpStatus.NOT_IMPLEMENTED);
        },
      }),
    )
    aa: number,
  ): number {
    return aa + 1;
  }
```

http://localhost:3000/bb?aa=xxx

```
{"statusCode":501,"message":"xxx Validation failed (numeric string is expected)"}
```

可以看到，状态码和 message 都改了：

# @UseFilters

你也可以加个 @UseFilters 来使用自己的 exception filter 处理。

我们在这里使用了 @UseFilters() 装饰器。 与 @Catch() 装饰器类似，它可以采用单个过滤器实例，或以逗号分隔的过滤器实例列表。 在这里，我们就地创建了 HttpExceptionFilter 的实例。 或者，您可以传递类（而不是实例），将实例化的责任留给框架，并启用依赖项注入。

ParseFloatPipe 是把参数转换为 float 类型的。

```
  @Get('cc')
  cc(@Query('cc', ParseFloatPipe) cc: number) {
    return cc + 1;
  }
```

http://localhost:3000/cc?cc=1.2

```
2.2
```

它也同样可以 new ParseFloatPipe 的形式，传入 errorHttpStatusCode 和 exceptionFactory。

剩下这些与 parse 有关的 pipe 我们都试一下：

# ParseBoolPipe：

```
  @Get('dd')
  dd(@Query('dd', ParseBoolPipe) dd: boolean) {
    return typeof dd;
  }
```

http://localhost:3000/dd?dd=false

```
boolean
```

# ParseArrayPipe：

```
  @Get('ee')
  ee(
    @Query(
      'ee',
      ParseArrayPipe,
      // new ParseArrayPipe({
      //   items: Number,
      // }),
    )
    ee: Array<number>,
  ) {
    return ee.reduce((total, item) => total + item, 0);
  }
```

这时会提示需要 class-validator 这个包：
这是可以用装饰器和非装饰器两种方式对 class 属性做验证的库
还会提示需要 class-transformer 这个包：
它是把普通对象转换为对应的 class 实例的包：

```
npm install -D class-validator class-transformer
```

http://localhost:3000/ee?ee=1,2,3

```
0123
```

new XxxPipe
指定 item 的类型。

这样就把数组每一项处理为 number 了。

```
  @Get('ee')
  ee(
    @Query(
      'ee',
      new ParseArrayPipe({
        items: Number,
      }),
    )
    ee: Array<number>,
  ) {
    return ee.reduce((total, item) => total + item, 0);
  }
```

```
6
```

# separator

此外，你还可以指定分隔符：

```
  @Get('ff')
  ff(
    @Query(
      'ff',
      new ParseArrayPipe({
        separator: '..',
        optional: true,
      }),
    )
    ff: Array<string>,
  ) {
    return ff;
  }
```

http://localhost:3000/ff?ff=a..b..c

```
["a","b","c"]
```

# ParseEnumPipe

假设我们有这样一个枚举：

```
enum Ggg {
  AAA = '111',
  BBB = '222',
  CCC = '333',
}
```

就可以用 ParseEnumPipe 来取：

```
 @Get('gg/:enum')
  gg(@Param('enum', new ParseEnumPipe(Ggg)) e: Ggg) {
    return e;
  }
```

http://localhost:3000/gg/333

```
333
```

有同学说，这不是多此一举么，本来 @Param 也能把它取出来呀。

ParseEnumPipe 还是有用的：

第一个是可以限制参数的取值范围：
http://localhost:3000/gg/444

```
{"statusCode":400,"message":"Validation failed (enum string is expected)","error":"Bad Request"}
```

如果参数值不是枚举里的，就会报错。

这个错误自然也可以通过 errorHttpStatusCode 和 exceptionFactory 来定制。

第二个是帮你转换类型

这里拿到的就直接是枚举类型了，如果有个方法的参数是这样的枚举类型，就可以直接传入。

# ParseUUIDPipe

UUID 是一种随机生成的几乎不可能重复的字符串，可以用来做 id。

它有 v3、v4、v5 3 个版本，我们用 uuid 包可以生成唯一的id

在参数里，可以用 ParseUUIDPipe 来校验是否是 UUID：

```
  @Get('hh/:uuid')
  hh(@Param('uuid', new ParseUUIDPipe()) uuid: string) {
    return uuid;
  }
```

如果不是 uuid 会抛异常：
http://localhost:3000/hh/444

```
{"statusCode":400,"message":"Validation failed (uuid is expected)","error":"Bad Request"}
```

# DefaultValuePipe

这个是设置参数默认值的：

```
  @Get('kkk')
  kkk(@Query('kkk', new DefaultValuePipe('aaa')) kkk: string) {
    return kkk;
  }
```

当你没传参数的时候，会使用默认值：
http://localhost:3000/kkk?kkk=bbb

```
bbb
```

http://localhost:3000/kkk

```
http://localhost:3000/kkk
```

还剩下 ValidationPipe 和 ParseFilePipe，这个我们之后再讲。

# 实现个 Pipe

```
nest g pipe aaa --flat --no-spec
```

生成一个 pipe，打印下参数值，返回 aaa：

```
import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';

@Injectable()
export class AaaPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    console.log(value, metadata);
    return 'aaa';
  }
}
```

在 handler 里用下：

```
  @Get('nnn/:bbb')
  nnn(@Query('aaa', AaaPipe) aaa: string, @Param('bbb', AaaPipe) bbb: number) {
    return aaa + bbb;
  }
```

http://localhost:3000/nnn/111?aaa=222

```
aaaaaa
```

返回的值是 aaaaaa，也就是说 pipe 的返回值就是传给 handler 的参数值。

打印的 value 就是 query、param 的值，而 metadata 里包含 type、metatype、data：

111 { metatype: [Function: Number], type: 'param', data: 'bbb' }
222 { metatype: [Function: String], type: 'query', data: 'aaa' }

type 就是 @Query、@Param、@Body 装饰器，或者自定义装饰器

而 metatype 是参数的 ts 类型

data 是传给 @Query、@Param、@Body 等装饰器的参数。

有了这些东西，做一下验证，抛出异常给 exception filter 处理，或者对 value 做些转换再传给 handler 就都是很简单的事情了。

# 总结

Pipe 是在参数传给 handler 之前做一些验证和转换的，有 9 个内置的 Pipe 可以直接用。

我们过了一遍内置的 ParseIntPipe、ParseBoolPipe、ParseArrayPipe、ParseUUIDPipe、ParseEnumPipe、ParseFloatPipe 还有 DefaultValuePipe。

剩下的 ValidationPipe 和 ParseFilePipe 之后的章节讲。

自己写一个 pipe 也很简单，就是实现 PipeTransform 接口的 transform 方法，它的返回值就是传给 handler 的值。

在 pipe 里可以拿到装饰器和 handler 参数的各种信息，基于这些来实现校验和转换就是很简单的事情了。
